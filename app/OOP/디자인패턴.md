# 디자인 패턴

디자인 패턴을 학습한다
실무적인 디자인 패턴의 개념을 익힌다. 

# GOF

# 팩토리 패턴

- 팩토리 메소드 패턴에서 구조와 구현의 분리를 이해한다.
- 장점 :
    - 템플릿을 사용하기 때문에 추상화를 가능하다
    - 구조와 구현의 분리가 사용된다.
    

### 요구사항

- 게임 아이템과 아이템 생성를 구현해 주세요.
    - 아이템을 생성하기 전에 데이터 베이스에서 아아티메 정보를 요청합니다.
    - 아이템을 생성 후  아이템 복제 등의 불법을 방지하기 위해 데이터 베이스에 아이템 생성 정보를 남깁니다.
- 아이템을 생성하는 주체를 ItemCreator로 이름 짓습니다.
- 아이템은 item이라는 interface로 다룰수 있도록 합니다.
    - item은 use 함수를 기본 함수로 갖고 있습니다.
- 현재 아이템 종류는 체력회복아이템 및 마력회복아이템 이 존재합니다.



# 싱글턴 패턴

- 싱글톤 패턴은 하나의 인스턴스를 생성하는 것입니다.
- 동일한 인스턴스가 생기면 안됩니다.
- 동일 한 인스턴스가 생기지 않도록 인스턴스 스태틱으로 관리하면 생성할 수 있습니다.

필드에 스태틱 인스턴스를 만들고 이를 통해서 통제 가능합니다. 

하지만 멀티 쓰레드에서는 여러 인스턴스가 생성될 가능성이 존재합니다.  어떻게 락이 걸리느냐 문제이기 때문입니다. 

→ 이를 방지 하기 위해서는 동기화를 해주어야 합니다. 

syncronized 키워드를 통해서 동기화를 진행 할 수 있습니다. 

# 프로토 타입 패턴

- 해당 패턴을 통해서 인스턴스를 복사하여 사용할 수 있다.

### 인스턴스 생상 비용이 높은경우

- 종류가 너무 많아서 클래스로 정리되지 않는 경우
- 클래스로부터 인스턴스 생성이 어려운 경우

자바에서는 깊은, 얇은 복사가 존재합니다. 

이를 고려 해서 프로토 타입을 생성해야합니다. 

즉 레퍼런스(주소) 복사를 고려해야하는것입니다. 

객체가 복사되는것, 주소가 복사되는것 고려하시기 바랍니다. 

→ 객체를 필드로 가지고 있다면 깊은 복사가 안 이루어질 수 있습니다. (자바의 프리미티브 타입은 기본으로 깊은 복사가 이루어집니다. )

but ! 객체를 필드로 가지고 있다면 

Cloneable  구현체의 impl에서 깊은 복사가 이루어지도록 구현해야한다. 

# 빌드업 패턴

- 복잡한 단계가 필요한 인스턴스 생성을 단순화(빌더 패턴)을 통해서 구현 할 수 있다.
- 복잡한 단계를 거쳐야 생성되는 객체의 구현을 서브 클래스에게 넘겨주는 패턴

즉 빌드업 패턴은 2가지로 구성된다. 

- 객체가 복잡하게 구성될수 있는경우
    
    ![Untitled](%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%20546aadb40cf441619f124f8710795001/Untitled.png)
    
    위의 경우는 director에서 하나의 메소드가 동작한다. 
    
     그리고 AbstractorBuilder를 통해서 복잡한 객체를 생성한다. 
    
    그리고 ConcreateBuilder를 통해서 확장성을 고려한 여러 객체가 생성 가능하다. 

    
- 많은 인자를 가진 객체를 생성을 다른객체의 도움으로 객체를 생성하는 패턴
    
    builder().setXXX().setXXX().build()
    

# 추상 팩토리 패턴(abstract Factory Pattern)

- 관련 있는 객체를 가상화 할 수 있다. ( 생성 부분의 가상화 / 관련 있는 객체 )

![Untitled](%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%20546aadb40cf441619f124f8710795001/Untitled%201.png)

추상 팩토리 구현 예

1. 먼저 abstractProductA를 구현합니다.  
2. 기능(역할)의 메소드를 정의합니다.  
3. 새로운 클래스 ProductA1, ProductA2를 통해서 기능을 사용할 객체를 구현합니다. 
4. 우리는 상품을 추상화한 특정 객체의 상위 버전을 만들었습니다.
5. 이를 ConcreateFactory를 통해서 한번에 불러오고 싶습니다. 
6. ConcreateFactory 클래스에서 createProductA()를 통해서 우리는 productA의 인스턴스를 생성 할 수 있습니다. (파라미터로 네임을 주던지 혹은 특정 코드를 줍니다.) 
7. 그러면 createProductA()에서 구현체로 나뉠것입니다. 상품이 존재하는지를 확인하고 없으면 만든다. 
8. 이러한  추상화된 상품이 여러개 존재 할 수 있습니다.  → concreateFactory 또한 추상화 합니다. 
9. → 위와 같은 방식으로 추상화 하여 큰 범주를 만들 수 있을 것 이라고 생각합니다. 

# 브릿지 패턴( Bridge Pattern )

- 기능 계층과 구현 계층의 분리

![Untitled](%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%20546aadb40cf441619f124f8710795001/Untitled%202.png)

기능이 정의된 추상클래스에서 기능을 구현한 클래스를 멤버 변수로 가지고 있는 패턴이 브릿지 패턴입니다. 

또한 추상클래스를 다시 정의할 수 있는 기능 또한 존재햐아힙니다. 

추상클래스는 역할(기능)인터페이스를 필드로 가지고 역할(기능)인터페이스는 Impl을 가집니다. 

추상 클래스 역시  역할필드를 재정의 할수있는 impl을 가지고 있습니다. 

브릿지 패턴은 추상클래스에서 기능을 사용 할 수 있습니다. 

브릿지 패턴은 어댑터 패턴과 비슷합니다.